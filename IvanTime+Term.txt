#include <mega8.h>
#include <delay.h>
#include <twim.c>
#include <Time_and_Clock.c>

unsigned char Sec = 0x55, Min = 0x59, Hour = 0x23, Day = 0x05, Dat = 31, Mounth = 12, Year = 15;
unsigned char Disp[16];//  0     1     2     3     4     5     6     7     8     9     0.    1.    2.    3.    4.    5.    6.    7.    8.    9.    Пн    Вт    Ср    Чт    Пт    Сб    Нд    -
unsigned char simv[28] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0xBF, 0x86, 0xDB, 0xCF, 0xE6, 0xED, 0xFD, 0x87, 0xFF, 0xEF, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x40};     //Оголошення масиву символів від 0 до 9 СC
unsigned char Day_in_Mounth[13] = {0xFF, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};    // Массив днів у місяцях
unsigned char x;

void EEPROM_write (unsigned int uiAddress, unsigned char ucData)
{
while(EECR & (1<<EEWE));
EEAR = uiAddress;
EEDR = ucData;
EECR |= (1<<EEMWE);
EECR |= (1<<EEWE);
}

unsigned char EEPROM_read (unsigned int uiAddress)
{
while(EECR & (1<<EEWE));
EEAR = uiAddress;
EECR |= (1<<EERE);
return EEDR;
}

unsigned char ASCtoDig (unsigned char ASC)  // Перетворення ASCII сииволів у Hex
    {
    unsigned char TMPS;
    switch (ASC)
        {
        case 0x30: TMPS = 0x00; break;
        case 0x31: TMPS = 0x01; break;     
        case 0x32: TMPS = 0x02; break;
        case 0x33: TMPS = 0x03; break;
        case 0x34: TMPS = 0x04; break;
        case 0x35: TMPS = 0x05; break;
        case 0x36: TMPS = 0x06; break;
        case 0x37: TMPS = 0x07; break;
        case 0x38: TMPS = 0x08; break;
        case 0x39: TMPS = 0x09; break;
        case 0x41: TMPS = 0x0A; break; 
        case 0x42: TMPS = 0x0B; break;     
        case 0x43: TMPS = 0x0C; break; 
        case 0x44: TMPS = 0x0D; break;    
        case 0x45: TMPS = 0x0E; break; 
        case 0x46: TMPS = 0x0F; break;     
        }
    return TMPS;
    }

unsigned char DigtoASC (unsigned char Dig)  // Перетворення чисел з Hex системми у сииволи ISCII
    {
    unsigned char TMPS;
    switch (Dig)
        {
        case 0x00: TMPS = 0x30; break; 
        case 0x01: TMPS = 0x31; break;
        case 0x02: TMPS = 0x32; break;
        case 0x03: TMPS = 0x33; break;
        case 0x04: TMPS = 0x34; break;
        case 0x05: TMPS = 0x35; break;
        case 0x06: TMPS = 0x36; break;
        case 0x07: TMPS = 0x37; break;
        case 0x08: TMPS = 0x38; break;
        case 0x09: TMPS = 0x39; break;
        case 0x0A: TMPS = 0x41; break;
        case 0x0B: TMPS = 0x42; break;
        case 0x0C: TMPS = 0x43; break;
        case 0x0D: TMPS = 0x44; break;
        case 0x0E: TMPS = 0x45; break;
        case 0x0F: TMPS = 0x46; break;
        }
    return TMPS;
    }

// Timer1 output compare A interrupt service routine
interrupt [TIM1_COMPA] void timer1_compa_isr(void)
{
SysTime_incr();
//----- Двійково-десятковий формат збереження даних
if ((0x0F & Sec) >= 0x09)
    {
    Sec &= 0xF0;                   
    if ((0xF0 & Sec) >= 0x50)
        {
        Sec = 0x00;
        if ((0x0F & Min) >= 0x09)
            {
            Min &= 0xF0;
            if ((0xF0 & Min) >= 0x50)
                {
                Min = 0x00;
                if (((0xF0 & Hour) >= 0x20))
                    {
                    if ((0x0F & Hour) >= 0x03)
                        {
                        Hour = 0x00;
                        if (Day >= 7)
                            {
                            Day = 0x01;
                            }
                        else
                            {
                            Day++;
                            }
                        //Date code insert
                        if (Dat >= Day_in_Mounth[Mounth])
                            {
                            Dat = 0x01;
                            if (Mounth >= 12)
                                {
                                Mounth = 0x01;
                                Year++;
                                if (Year % 4)   // Перевірка на високосний рік
                                    {
                                    Day_in_Mounth[2] = 28;
                                    }
                                else
                                    {
                                    Day_in_Mounth[2] = 29;
                                    }
                                }
                            else
                                {
                                Mounth++;
                                }
                            }
                        else
                            {
                            Dat++;
                            }
                        }
                    else
                        {
                        Hour++;
                        }
                    }
                else
                    {
                    if ((0x0F & Hour) >= 0x09)
                        {
                        Hour &= 0xF0;
                        Hour = Hour + 0x10;
                        }
                    else
                        {
                        Hour++;
                        }
                    }                
                }
            else
                {
                Min = Min + 0x10;
                }
            }
        else
            {
            Min++;
            }
        }
    else
        {
        Sec = Sec + 0x10;
        }
    }
else
    {
    Sec++;
    }
//----- Бінарний формат збереження даних
//if (Sec >= 59)
//    {
//    Sec = 0x00;
//    if (Min >= 59)
//        {
//        Min = 0x00;
//        if (Hour >= 23)
//            {
//            Hour = 0x00;          
//            if (Day >= 7)
//                {
//                Day = 0x01;
//                }
//            else
//                {
//                Day++;
//                }
//            if (Dat >= Day_in_Mounth)
//                {
//                Dat = 0x01;
//                if (Mounth >= 12)
//                    {
//                    Mounth = 0x01;
//                    Year++;
//                    if (Year % 4)   // Перевірка на високосний рік
//                        {
//                        Day_in_Mounth[2] = 28;
//                        }
//                    else
//                        {
//                        Day_in_Mounth[2] = 29;
//                        }
//                    }
//                else
//                    {
//                    Mounth++;
//                    }
//                }
//            else
//                {
//                Dat++;
//                }
//            }
//        else
//            {
//            Hour++;
//            }
//        }
//    else
//        {
//        Min++;
//        }
//    }
//else
//    {
//    Sec++;
//    }
//------
Disp[3] = 0x0F & Min;
Disp[2] = (Min >> 4);
Disp[1] = 0x0F & Hour;
Disp[0] = (Hour >> 4);


Disp[7] = 0x0F & Sec;
Disp[6] = (Sec >> 4);
Disp[5] =  Day_in_Mounth[2] % 10;
Disp[4] =  Day_in_Mounth[2] / 10;

Disp[8] = Day + 19; //Дні неділі
//--- debug mode begin
Disp[9] = 125;
Disp[10] = Dat / 10;            //Dat Dec
Disp[11] = (Dat % 10) + 10;     //Dat ED
Disp[12] = Mounth / 10;         //Mounth Dec
Disp[13] = (Mounth % 10) + 10;  //Mounth ED
Disp[14] = Year / 10;           //Year Dec
Disp[15] = Year % 10;           //Year ED
//--- debug mode end

if (0x00 == Sec % 0x02)     // Блимач
    {
    Disp[1] = Disp[1] + 0x0A;
    }

}

void init_clock (void)
{
unsigned char RTC_Data[8];  // Массив для тимчасового збереження данних з годинника реального часу

Sec = (10 * (RTC_Data[0] >> 4)) + (0b00001111 & RTC_Data[0]); // Переклад з BDC y BIN Секунди
Min = (10 * (RTC_Data[1] >> 4)) + (0b00001111 & RTC_Data[1]); // Переклад з BDC y BIN Хвилини
Hour = (0b00001111 & RTC_Data[2]); // Переклад з BDC y BIN Години  --------------------------
Day = RTC_Data[3]; // День неділі
Dat = (10 * (RTC_Data[4] >> 4)) + (0b00001111 & RTC_Data[4]); // Переклад з BDC y BIN Число
Mounth = (10 * (RTC_Data[5] >> 4)) + (0b00001111 & RTC_Data[5]); // Переклад з BDC y BIN Місяць
Year = (10 * (RTC_Data[6] >> 4)) + (0b00001111 & RTC_Data[6]); // Переклад з BDC y BIN Рік
}         

interrupt [TIM2_COMP] void timer2_comp_isr(void) // Оновлення дисплею
{
if (PORTC >=0x0F)   //Standart 0x08
    {
    PORTC = 0x00;
    x = 0x00;
    PORTD = simv[Disp[x]];
    }
else
    {
    PORTC++;
    x++;
    PORTD = simv[Disp[x]];
    }
}



void main (void)
{
DDRB = 0b10000000;
DDRC = 0x0F;
DDRD = 0xFF; // Segments

//#asm("cli")
EEPROM_write (0x0001, 0x12);
EEPROM_write (0x0002, 0x7A);
//#asm("sei")

// Timer/Counter 2 initialization
// Clock source: System Clock
// Clock value: 31,250 kHz
// Mode: CTC top=OCR2
// OC2 output: Disconnected
ASSR=0x00;  //
TCCR2=0x0E; // 0x0E
TCNT2=0x00; //
OCR2=0x5D;  // 0x7D

// Timer/Counter 1 initialization
// Clock source: System Clock
// Clock value: 31,250 kHz
// Mode: CTC top=OCR1A
// OC1A output: Discon.
// OC1B output: Discon.
// Noise Canceler: Off
// Input Capture on Falling Edge
// Timer1 Overflow Interrupt: Off
// Input Capture Interrupt: Off
// Compare A Match Interrupt: On
// Compare B Match Interrupt: Off
TCCR1A=0x00;
TCCR1B=0x0C;
TCNT1H=0x00;
TCNT1L=0x00;
ICR1H=0x00;
ICR1L=0x00;
OCR1AH=EEPROM_read (0x0002);  // 0x7A
OCR1AL=EEPROM_read (0x0001);  // 0x12
OCR1BH=0x00;
OCR1BL=0x00;
// Timer(s)/Counter(s) Interrupt(s) initialization
TIMSK=0x90;

// Global enable interrupts
#asm("sei")

TWI_MasterInit(100);
I2C_Buff[0] = 0b11010001;
Get_RTC_time();

while(1)
    {

    }   
}